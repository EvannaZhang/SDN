# SDN Report
    张艺凡 曹若骁 雷皓凌
---

## Background
  - SDN

    Software Defined Network (SDN) is a network framework, not actually a specific technology or protocol. OpenFlow is a specific protocol to realize the separation of control and forwarding. The essence of SDN is to use software to control and manage the network.

    One feature of generally used SDN is the separation of control plane and data plane. SDN can support centralized network state control, and realize the transparency of the underlying network facilities to the upper applications.

    SDN has the ability of flexible software programming, which makes the automation management and control ability of the network have been improved unprecedentedly. It can effectively solve the problems faced by the current network system, such as the limited expansion of resource scale, the poor flexibility of networking, and the difficulty of quickly meeting the business requirements.

  - RYU

	RYU is a relatively lightweight controller platform written in Python. It is a component-based software defined networking framework. Ryu provides software components with well defined API that make it easy for developers to create new network management and control applications. Ryu supports various protocols for managing network devices, such as OpenFlow, Netconf, OF-config, etc. About OpenFlow, Ryu supports fully 1.0, 1.2, 1.3, 1.4, 1.5 and Nicira Extensions.

    Ryu is the controller that can control switches by configuring the flow table rules through protocols like OpenFlow.

  - mininet

	Mininet is a network emulator, which is connected by some virtual end hosts, switches and routers. It uses the lightweight virtualization technology to make the system comparable to the real network.

    Using Mininet, we can easily create a user-defined network topology. It can run on computer, server, virtual machine, or cloud. Mininet provides Python API and the code running on mininet can be easily ported to hardware devices supporting OpenFlow. And programs running on Linux can basically run on mininet, such as Wireshark.

---

## Implementation

In this project, we use the Ryu controller to get the topology information generated by mininet, calculate the shortest path, build flow table for switches, then install those table by controller to implement the network.

- ARP reply

```python
            if arp_msg.opcode == arp.ARP_REQUEST:

                self.logger.warning("Received ARP REQUEST on switch%d/%d:  Who has %s?  Tell %s",
                                    dp.id, in_port, arp_msg.dst_ip, arp_msg.src_mac)

                # TODO:  Generate a *REPLY* for this request based on your switch state

                # Here is an example way to send an ARP packet using the ofctl utilities
                r_mac = ""
                found = False
                for translation in self.tm.ip_to_mac:
                    if translation[0] == arp_msg.dst_ip:
                        r_mac = translation[1]
                        found = True
                        break
                if found:
                    ofctl.send_arp(vlan_id=VLANID_NONE, src_port=ofctl.dp.ofproto.OFPP_CONTROLLER, arp_opcode=2,
                                   dst_mac=arp_msg.src_mac, sender_mac=r_mac, sender_ip=arp_msg.dst_ip, target_ip=arp_msg.src_ip,
                                   target_mac=arp_msg.src_mac, output_port=in_port)
```

- Path calculation by Dijkstra's algorithm and spanning tree 

```python
    def dijkstra(self, start):
        q = queue.PriorityQueue(0)
        for device in self.tm.all_devices:
            if device is not start:
                device.distance = MAX
            else:
                device.distance = 0
            device.checked = False
            device.path = []
            device.shortestpath = []
            q.put((device.distance, device))

        while  q.qsize()>0:
            first = q.get()
            top = first[1]
            if isinstance(top, TMHost):
                if not top.checked:
                    top.checked = True
                    if top.distance == 0:
                        top.neighbors[0][0].distance = 1
                        #top.neighbors[0][0].shortestpath = top.shortestpath+[top.name]
                        q.put((1, top.neighbors[0][0]))
                    else:
                        continue
            elif isinstance(top, TMSwitch):
                for neighbor in top.neighbors:
                    neighbor_type_switch = isinstance(neighbor[0], TMSwitch)
                    if not neighbor[0].checked:
                        adjacent = False
                        for i in neighbor[0].neighbors:
                            if i[0] is top:
                                adjacent = True
                        if neighbor[1].is_live():
                            if (not neighbor_type_switch) or (neighbor_type_switch and adjacent):
                                if neighbor[0].distance < top.distance + 1:
                                    continue
                                neighbor[0].path = top.path + [(top, neighbor[1].port_no)]
                                neighbor[0].shortestpath = top.shortestpath + [top.name]
                                neighbor[0].distance = top.distance + 1
                                q.put((neighbor[0].distance, neighbor[0]))
                top.checked = True
```

In the calculation progress, as the link weights equally, the spanning tree is calculated directly.

- Flow table update

```python
    def rules_update(self):
        for i in self.tm.all_devices:
            if isinstance(i, TMHost):
                for point, num_port in i.path:
                    point.actions = []
                    self.delete_forwarding_rule(point.get_dp(), "ff:ff:ff:ff:ff:ff")

        for i in self.tm.all_devices:
            if isinstance(i, TMHost):
                for point, num_port in i.path:
                    point.flag = False
                    self.delete_forwarding_rule(point.get_dp(), i.get_mac())
                    self.add_forwarding_rule(point.get_dp(), i.get_mac(), num_port)
                    datapath = point.get_dp()
                    point.actions += [datapath.ofproto_parser.OFPActionOutput(num_port)]
                    #self.add_forwarding_rule(point.get_dp(), "00:00:00:00:00:00", num_port)

        if self.flooding_flag:
            for i in self.tm.all_devices:
                if isinstance(i, TMHost):
                    for point, num_port in i.path:
                        if not point.flag:
                            point.flag = True
                            ofctl = OfCtl.factory(point.get_dp(), self.logger)
                            ofctl.set_flow(cookie=0, priority=0, dl_vlan=VLANID_NONE, dl_dst="ff:ff:ff:ff:ff:ff", actions=point.actions)
```



---

## Testing

We test our code with different topologies.

- Tree
	- Topology Figure
	![Tree1.jpg](https://i.loli.net/2020/01/06/PQ5wv7oBrJnAs3z.jpg)
	- Shortest Path Table
	<img src="https://i.loli.net/2020/01/06/k2N3AZx9cGHrzFD.png" alt="tree3.png" style="zoom:80%;" />
	- Pingall test
	<img src="https://i.loli.net/2020/01/06/63kYcMnUJtKxpCX.png" alt="tree4.png" style="zoom:80%;" />
	- Flow table
	![tree5.png](https://i.loli.net/2020/01/06/9VjDo7hRnP15e4y.png)
	- Topology Output
	<img src="https://i.loli.net/2020/01/06/A5jrLCdZUX37bKp.png" alt="tree2.png" style="zoom:80%;" />

- Triangle
	- Topology Figure
	<img src="https://i.loli.net/2020/01/06/G76R2VUAXmhZkBT.png" alt="triang1.png" style="zoom: 80%;" />
	- Shortest Path Table
	<img src="https://i.loli.net/2020/01/06/eRJmh3p4iDfoQub.png" alt="triang2.png" style="zoom:80%;" />
	- Pingall test
	<img src="https://i.loli.net/2020/01/06/c8M3ztoVyBDe6IE.png" alt="triang3.png" style="zoom:80%;" />
	- Topology Output
	<img src="https://i.loli.net/2020/01/06/raP9dLJBE265Fsn.png" alt="triang4.png" style="zoom:80%;" />

	In this testing case, we break the link S1-S2 down.

	- Pingall after link down
	<img src="https://i.loli.net/2020/01/06/9PR5ZBVbUL784Jt.png" alt="triang5.png" style="zoom:80%;" />
	- Topology Output after link down
	<img src="https://i.loli.net/2020/01/06/L6CKnPuvaYqcrob.png" alt="triang6.png" style="zoom:80%;" />

	Then connect two switches again, the result returned to initial state.

- Mesh
	- Topology Figure
	<img src="https://i.loli.net/2020/01/06/IxEZ6l8HC3PvyBX.png" alt="mesh1.png" style="zoom:80%;" />
	- Shortest Path Table
	![mesh2.png](https://i.loli.net/2020/01/06/Ot75WDrfbpeolVZ.png)
	- Pingall test
	<img src="https://i.loli.net/2020/01/06/mW9JfnN2PwpYejz.png" alt="mesh3.png" style="zoom:80%;" />
	- Topology Output
	![mesh4.png](https://i.loli.net/2020/01/06/vicTuB1L2fyEqaA.png)

	In this testing case, we break the link S1-S2, S3-S4, S1-S5 down.

	- Pingall after link down
	<img src="https://i.loli.net/2020/01/06/KI8ckGjJNAPm9lg.png" alt="mesh5.png" style="zoom:80%;" />
	- Topology Output after link down
	![mesh6.png](https://i.loli.net/2020/01/06/jx5lNiRZ43pwaUb.png)

	Then connect all links again, the result returned to initial state.

- Spanning tree
	- Forwarding table of switches in triangle structure
	![1111.png](https://i.loli.net/2020/01/07/lVJGWtpo29PKNMT.png)
	- Wireshark packets captured when broadcast storm by ping nonexistent address
	![1121.png](https://i.loli.net/2020/01/07/9SsbMcJexdIkqhp.png)

---

## Contribution
张艺凡：Flow table building, Shortest path calculation.

曹若骁：Building environment, Topology output, Testing.

雷皓凌：Testing, debugging, Production of slides and report.

---

## Conclusion

- Conclusion

	In this project, we have learned the concept and essence of SDN. And we successfully realized the SDN controller, calculation of shortest path by Dijkstra algorithm, and the installation of flow table rules.

	And we have the ability to analyze the broadcast storm problem then calculate and install a spanning tree for broadcasts.

- Problem

	We have met the vagrant environment problem in the beginning, so we use Ubuntu Linux to simulate and test our codes.

	Then we meet the challenge to build the spanning tree in order to solve the broadcast storm. Finally we work it out.

	There is still a problem that the host can not be deleted even we add a delete event function.

	```python
	    @set_ev_cls(event.EventHostDelete)
	    def handle_host_delete(self, ev):
	        """
	        Event handler indicating when a host has been deleted
	        """
	        host = ev.host

	        self.logger.warn("Host Deleted:  %s (IPs:  %s) on switch%s/%s (%s)",
	                         host.mac, host.ipv4,
	                         host.port.dpid, host.port.port_no, host.port.hw_addr)

	        # TODO:  Update network topology and flow rules
	        self.tm.delete_host(ev)
	        self.flowtable_update()
	```
	![hostdelete.png](https://i.loli.net/2020/01/07/I9lZqDrfpjS75Wy.png)










